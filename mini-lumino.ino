#include <LEDMatrixDriver.hpp>
#include <Ticker.h>
#include <ESP8266WiFi.h>
#include "secrets.h"

// Pin for the software CS
const uint8_t LEDMATRIX_CS_PIN = 15;

// Define LED Matrix dimensions
const int MODULE_HEIGHT = 8; // height of a single LED matrix module
const int MODULE_WIDTH = 8; // width of a single LED matrix module
const int LEDMATRIX_WIDTH = 64; // physical width of the display
const int LEDMATRIX_HEIGHT = 16; // physical height of the display
const int LEDMATRIX_SEGMENTS = (LEDMATRIX_WIDTH / MODULE_WIDTH) * (LEDMATRIX_HEIGHT / MODULE_HEIGHT); // total number of segments
const int PROGRESS_HEIGHT = 2;

// The LEDMatrixDriver class instance
LEDMatrixDriver lmd(LEDMATRIX_SEGMENTS, LEDMATRIX_CS_PIN);
Ticker scroller;
WiFiClient mpd_client;

int x=0, y=0;
char stop[] = { 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0 };
char play[] = { 0x8, 0xc, 0xe, 0xc, 0x8, 0x0 };
char pause[] = { 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x0 };
char* display_text = "";

char font[][4] = {
	{0x0, 0x0, 0x0, 0x0},
	{0x1, 0x1, 0x0, 0x1},
	{0x5, 0x5, 0x0, 0x0},
	{0xa, 0xf, 0xa, 0xf},
	{0x7, 0x6, 0x3, 0x7},
	{0x9, 0x2, 0x4, 0x9},
	{0x6, 0x6, 0xa, 0xf},
	{0x1, 0x1, 0x0, 0x0},
	{0x1, 0x2, 0x2, 0x1},
	{0x2, 0x1, 0x1, 0x2},
	{0x5, 0x2, 0x5, 0x0},
	{0x0, 0x2, 0x7, 0x2},
	{0x0, 0x0, 0x1, 0x2},
	{0x0, 0x0, 0x7, 0x0},
	{0x0, 0x0, 0x0, 0x1},
	{0x1, 0x2, 0x4, 0x8},
	{0x3, 0x5, 0x5, 0x6},
	{0x1, 0x3, 0x1, 0x1},
	{0x6, 0x1, 0x6, 0x7},
	{0x6, 0x3, 0x1, 0x6},
	{0x5, 0x7, 0x1, 0x1},
	{0x7, 0x4, 0x3, 0x7},
	{0x4, 0x7, 0x5, 0x3},
	{0x6, 0x1, 0x1, 0x1},
	{0x7, 0x5, 0x7, 0x7},
	{0x6, 0x5, 0x3, 0x1},
	{0x1, 0x0, 0x1, 0x0},
	{0x1, 0x0, 0x1, 0x2},
	{0x0, 0x1, 0x2, 0x1},
	{0x0, 0x7, 0x0, 0x7},
	{0x0, 0x2, 0x1, 0x2},
	{0x7, 0x1, 0x3, 0x2},
	{0x6, 0x9, 0xa, 0x7},
	{0x2, 0x5, 0x7, 0x5},
	{0x6, 0x7, 0x5, 0x6},
	{0x3, 0x4, 0x4, 0x3},
	{0x6, 0x5, 0x5, 0x6},
	{0x3, 0x6, 0x4, 0x7},
	{0x7, 0x4, 0x6, 0x4},
	{0x7, 0x4, 0x5, 0x7},
	{0x5, 0x5, 0x7, 0x5},
	{0x7, 0x2, 0x2, 0x7},
	{0x1, 0x1, 0x5, 0x7},
	{0x5, 0x6, 0x6, 0x5},
	{0x4, 0x4, 0x4, 0x7},
	{0x9, 0xf, 0x9, 0x9},
	{0x7, 0x5, 0x5, 0x5},
	{0x6, 0x9, 0x9, 0x6},
	{0x6, 0x5, 0x6, 0x4},
	{0x4, 0xa, 0xa, 0x7},
	{0x6, 0x5, 0x6, 0x5},
	{0x3, 0x6, 0x3, 0x6},
	{0x7, 0x2, 0x2, 0x2},
	{0x5, 0x5, 0x5, 0x3},
	{0x5, 0x5, 0x7, 0x2},
	{0x9, 0x9, 0xf, 0x6},
	{0x5, 0x5, 0x2, 0x5},
	{0x5, 0x5, 0x2, 0x2},
	{0xf, 0x2, 0x4, 0xf},
	{0x3, 0x2, 0x2, 0x3},
	{0x8, 0x4, 0x2, 0x1},
	{0x3, 0x1, 0x1, 0x3},
	{0x2, 0x5, 0x0, 0x0},
	{0x0, 0x0, 0x0, 0xf},
	{0x2, 0x1, 0x0, 0x0},
	{0x0, 0x3, 0x5, 0x3},
	{0x4, 0x6, 0x5, 0x6},
	{0x0, 0x3, 0x4, 0x3},
	{0x1, 0x3, 0x5, 0x3},
	{0x3, 0x5, 0x6, 0x3},
	{0x1, 0x2, 0x3, 0x2},
	{0x3, 0x4, 0x5, 0x3},
	{0x4, 0x4, 0x7, 0x5},
	{0x1, 0x0, 0x1, 0x1},
	{0x1, 0x1, 0x5, 0x2},
	{0x4, 0x5, 0x6, 0x5},
	{0x2, 0x2, 0x2, 0x1},
	{0x8, 0xf, 0xb, 0xb},
	{0x0, 0x6, 0x5, 0x5},
	{0x0, 0x2, 0x5, 0x2},
	{0x2, 0x5, 0x6, 0x4},
	{0x4, 0xa, 0x6, 0x3},
	{0x4, 0x6, 0x4, 0x4},
	{0x0, 0x3, 0x2, 0x6},
	{0x2, 0x7, 0x2, 0x2},
	{0x0, 0x5, 0x5, 0x3},
	{0x0, 0x5, 0x7, 0x2},
	{0x0, 0xb, 0xb, 0x6},
	{0x0, 0x5, 0x2, 0x5},
	{0x0, 0x5, 0x2, 0x2},
	{0x0, 0x6, 0x2, 0x3},
	{0x3, 0x2, 0x6, 0x3},
	{0x1, 0x1, 0x1, 0x1},
	{0x6, 0x2, 0x3, 0x6},
	{0x0, 0x5, 0xa, 0x0}
};

void setup() {
	// init the display
	lmd.setEnabled(true);
	lmd.setIntensity(2); // 0 = low, 10 = high
	Serial.begin(9600); // init serial for debugging
	display_text = "...";
	text(display_text, 0);

	WiFi.mode(WIFI_STA);
	//WiFi.begin(ssid, password);
	//while (WiFi.status() != WL_CONNECTED) {
	//	delay(500);
	//}
	display_text = "CONNECTING...";
	text(display_text, 0);
}

void loop() {
	display_text = "A";
	scroller.attach(0.5, rotateText);
	while (true) {
		//if (!mpd_client.connect("10.42.0.3", 6600)){
		//	return;
		//}
		//String resp = mpd_client.readStringUntil('\n');
		//String title = "";
		//String name = "";
		//String state = "";
		//if (resp.indexOf("OK") == 0) {
		//	mpd_client.print("currentsong\n");
		//	resp = mpd_client.readStringUntil('\n');
		//	while (!(resp.lastIndexOf("Id") == 0)) {
		//		if (resp.lastIndexOf("Title: ") == 0) {
		//			title = resp.substring(7, resp.length());
		//			Serial.println(title);
		//		}
		//		if (resp.lastIndexOf("Name: ") == 0) {
		//			name = resp.substring(6, resp.length());
		//			Serial.println(name);
		//		}
		//		resp = mpd_client.readStringUntil('\n');
		//	}

		//	mpd_client.print("status\n");
		//	resp = mpd_client.readStringUntil('\n');
		//	while (!(resp.lastIndexOf("audio") == 0) && !(resp.lastIndexOf("songid") == 0)) {
		//		if (resp.lastIndexOf("state: ") == 0) {
		//			state = resp.substring(7, resp.length());
		//			Serial.println(state);
		//		}
		//		resp = mpd_client.readStringUntil('\n');
		//	}
		//}

		//if (state == "play") {
		//	status(play);
		//} else if (state == "stop") {
		//	status(stop);
		//} else if (state == "pause") {
		//	status(pause);
		//}

		String title = "";
		String name = "";
		String song_text = name + ' - ' + title;
		status(play);
		//display_text = (char*) song_text.c_str();
		display_text = const_cast<char*>(title.c_str());
		//text(display_text, 0);

		for (float prog = 0.0; prog <= 1.0; prog += 0.01) {
			progress(prog);
			delay(10);
		}
		progress(1.0);
		delay(10);
		for (float prog = 1.0; prog >= 0.0; prog -= 0.01) {
			progress(prog);
			delay(10);
		}
		mpd_client.stop();
	}
}

void progress(float prog) {
	int progress_shown = (int)(prog * (LEDMATRIX_WIDTH - 1));
	for (int progress_row = LEDMATRIX_HEIGHT; progress_row >= (LEDMATRIX_HEIGHT - PROGRESS_HEIGHT); progress_row--) {
		for (int x = 0; x <= progress_shown; x++) {
			setPixel(x, progress_row, 1);
		}
		for (int x = progress_shown + 1; x < LEDMATRIX_WIDTH; x++) {
			setPixel(x, progress_row, 0);
		}
		if (progress_shown <= 1) {
			setPixel(0, progress_row, 0);
		}
	}

	lmd.display();
}

void setPixel(int x, int y, bool value) {
	// LEDMatrixDriver is only designed to address one-matrix-heigh displays.
	// To archive multiple stacked displays on top of each other we just fake
	// a very long display and map y-coords >=8 onto the next segment by adding
	// 64 to the x value
	int real_x = 0;
	int real_y = 0;

	real_x = (((int)(y / MODULE_HEIGHT)) * LEDMATRIX_WIDTH) + x;
	real_y = y - (((int)(y / MODULE_HEIGHT)) * MODULE_HEIGHT);

	lmd.setPixel(real_x, real_y, value);
}

void status(char new_status[]) {
	for (int icon_line = 5; icon_line >= 0; icon_line--) {
		char line = new_status[icon_line];
		for (int x = 0; x <= 5; x++) {
			bool pixel_state = line & (0x20 >> x); // we want the sixth (0x20) pixel of that number)
			setPixel(x, icon_line + 7, pixel_state);
		}
	}
	lmd.display();
}

void text(char text[], int l_offset) {
	for (int c = 0; c < (strlen(text)); c++) {
		char letter = text[c];
		for (int line = 0; line <= 3; line++) {
			char render_line = font[((int) letter) - 32][line];
			for (int x = 0; x <= 3; x++) {
				bool pixel_state = render_line & (0x8 >> x); // we want the fourth (0x8) pixel of that number)
				int l_pos = (x + 7 + (c * 4)) - l_offset;
				if (l_pos >= 7 && l_pos < LEDMATRIX_WIDTH) {
					setPixel(l_pos, line + 6, pixel_state);
				}
			}
		}
	}

	lmd.display();
}

int current_offset = -4;
void rotateText() {
	int max_length = strlen(display_text) * 4;
	int px_visible = LEDMATRIX_WIDTH - 7;
	int overlap = max_length - px_visible;
	overlap += 0;
	current_offset++;

	if (current_offset >= overlap) {
		text(display_text, overlap);
		if (current_offset >= overlap + 2) {
			current_offset = -6;
		}
	} else if (current_offset < 0) {
		text(display_text, 0);
	} else {
		text(display_text, current_offset);
	}
}
